/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer;

import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.db.NitriteController;
import eu.fasten.vulnerabilityproducer.utils.PatchFarmer;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import org.apache.commons.io.FileUtils;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import static com.mongodb.client.model.Filters.eq;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;

public class PatchFarmerTest {

    // Inject Java Http Client to test
    JavaHttpClient clientMock = Mockito.mock(JavaHttpClient.class);

    // Inject mock database in order to test
    MongoDatabase dbMock = Mockito.mock(MongoDatabase.class);
    MongoCollection<Document> commitsMock = Mockito.mock(MongoCollection.class);
    MongoCollection<Document> prsMock = Mockito.mock(MongoCollection.class);
    MongoCollection<Document> issuesMock = Mockito.mock(MongoCollection.class);
    NitriteController nc = Mockito.mock(NitriteController.class);
    private PatchFarmer patchFarmer;

    static final String validJSON = "{" +
            "\"comment\":\"Testing\"," +
            "\"cve_id\":\"CVE-TEST-TEST\"," +
            "\"cwes\":[]," +
            "\"description\":\"Retrieve Relevant files\"," +
            "\"exploit_exists\":false," +
            "\"has_annotations\":true," +
            "\"is_processed\":true," +
            "\"langs\":[]," +
            "\"master_commit\":{" +
                "\"commit_hash\":\"hash\"," +
                "\"commit_link\":\"https://github.com/generic_commit\"," +
                "\"relevant_files\":[\"./src/index.c\",\"./src/mock.c\"]," +
                "\"repo_name\":\"test\"," +
                "\"repo_owner\":\"random\"," +
                "\"repo_url\":\"" +
            "\"}," +
            "\"products\":[]," +
            "\"references\":[]," +
            "\"score\":null" +
            "}";

    final String emptyMasterCommit = "{" +
            "\"comment\":\"Testing JSON body valid\"," +
            "\"cve_id\":\"CVE-TEST-TEST\"," +
            "\"cwes\":[]," +
            "\"description\":\"n/a\"," +
            "\"exploit_exists\":false," +
            "\"has_annotations\":true," +
            "\"is_processed\":true," +
            "\"langs\":[\"ANY\"]," +
            "\"master_commit\":{}," +
            "\"products\":[{\"product\":\"python\",\"vendor\":\"python\"}]," +
            "\"references\":[]," +
            "\"score\":null" +
            "}";

    final String errorJSON = "{\"code\":404,\"error\":\"Not found\"}";

    @BeforeEach
    public void setup() {
        when(dbMock.getCollection("commits")).thenReturn(commitsMock);
        when(dbMock.getCollection("pull_requests")).thenReturn(prsMock);
        when(dbMock.getCollection("issues")).thenReturn(issuesMock);
        patchFarmer = new PatchFarmer(dbMock, clientMock);
    }

    public String readFile(String filePath) throws IOException {
        File file = new File(filePath);
        return FileUtils.readFileToString(file, StandardCharsets.UTF_8);
    }

    @Test
    public void parsingCommitsFromMongo() throws IOException {
        // Setup mocks to test the response
        String patchLink = "https://github.com/python/cpython/commit/fbf648ebba32bbc5aa571a4b09e2062a65fd2492";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2013-01-14T03:59:38Z");
        String jsonCommit = readFile("./src/test/resources/patches/commit.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonCommit);

        // Call parse Commit method
        patchFarmer.parseCommit(v, patchLink);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(1968);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch("Lib/test/test_socket.py", "2014-01-14T03:59:38Z", hunks);

        assertEquals(v.getPatches().size(), 4);
        List<String> filenames = v.getPatches().stream().map(Vulnerability.Patch::getFileName).collect(Collectors.toList());
        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingCommitsFromGithubAPI() throws Exception {
        String patchLink = "https://github.com/python/cpython/commit/fbf648ebba32bbc5aa571a4b09e2062a65fd2492";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2013-01-14T03:59:38Z");
        String jsonCommit = readFile("./src/test/resources/patches/commit.txt");
        when(nc.findPatchEntry(patchLink)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonCommit);

        // Call parse Commit method
        v.addReference(patchLink);
        patchFarmer.parseReferences(v, nc);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(1968);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch("Lib/test/test_socket.py", "2014-01-14T03:59:38Z", hunks);

        assertEquals(v.getPatches().size(), 4);
        List<String> filenames = v.getPatches().stream().map(Vulnerability.Patch::getFileName).collect(Collectors.toList());
        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingPullRequestsGHTorrent() throws IOException {
        // Setup mocks to test the response
        String prLink = "https://github.com/omniauth/omniauth-oauth2/pull/25";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2012-08-08T09:26:41Z");
        String jsonCommit = readFile("./src/test/resources/patches/pr.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonCommit);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/pr_commit.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        patchFarmer.parsePullRequest(v, prLink);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(49);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch(
                "lib/omniauth/strategies/oauth2.rb",
                "2012-09-08T09:26:41Z",
                hunks);

        assertEquals(v.getPatches().size(), 1);
        List<String> filenames = v.getPatches().stream()
                .map(Vulnerability.Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingPullRequestsGithub() throws Exception {
        // Setup mocks to test the response
        String prLink = "https://github.com/omniauth/omniauth-oauth2/pull/25";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2012-08-08T09:26:41Z");
        String jsonCommit = readFile("./src/test/resources/patches/pr.txt");
        when(nc.findPatchEntry(prLink)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonCommit);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/pr_commit.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        v.addReference(prLink);
        patchFarmer.parseReferences(v, nc);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(49);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch(
                "lib/omniauth/strategies/oauth2.rb",
                "2012-09-08T09:26:41Z",
                hunks);

        assertEquals(v.getPatches().size(), 1);
        List<String> filenames = v.getPatches().stream()
                .map(Vulnerability.Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingIssuesGHTorrent() throws Exception {
        // Setup mocks to test the response
        String issueLink = "https://github.com/python/cpython/pull/32";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2015-04-08T09:26:41Z");
        String jsonIssue = readFile("./src/test/resources/patches/issue.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonIssue);

        // Mock pull request behaviour
        String jsonPullRequest = readFile("./src/test/resources/patches/pr_issue.txt");

        FindIterable mockIterablePR = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterablePR);
        Document mockDocumentPR = Mockito.mock(Document.class);
        when(mockIterablePR.first()).thenReturn(mockDocumentPR);
        when(mockDocumentPR.toJson()).thenReturn(jsonPullRequest);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/commit_issue.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        patchFarmer.parseIssues(v, issueLink);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(13);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch(
                "Lib/importlib/abc.py",
                "2017-02-16T02:00:32Z",
                hunks);

        assertEquals(5, v.getPatches().size());
        List<String> filenames = v.getPatches().stream()
                .map(Vulnerability.Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingIssuesGithub() throws Exception {
        // Setup mocks to test the response
        String issueLink = "https://github.com/python/cpython/pull/32";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2015-04-08T09:26:41Z");
        String jsonIssue = readFile("./src/test/resources/patches/issue.txt");
        when(nc.findPatchEntry(issueLink)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonIssue);

        // Mock pull request behaviour
        String jsonPullRequest = readFile("./src/test/resources/patches/pr_issue.txt");

        FindIterable mockIterablePR = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterablePR);
        Document mockDocumentPR = Mockito.mock(Document.class);
        when(mockIterablePR.first()).thenReturn(mockDocumentPR);
        when(mockDocumentPR.toJson()).thenReturn(jsonPullRequest);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/commit_issue.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        v.addReference(issueLink);
        patchFarmer.parseReferences(v, nc);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(13);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch(
                "Lib/importlib/abc.py",
                "2017-02-16T02:00:32Z",
                hunks);

        assertEquals(5, v.getPatches().size());
        List<String> filenames = v.getPatches().stream()
                .map(Vulnerability.Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void testPatchEntryAlreadyInNitrite() {
        NitriteController nc = Mockito.mock(NitriteController.class);
        Vulnerability v = new Vulnerability("TEST");
        v.addReference("ref");
        HashSet<Vulnerability.Patch> files = new HashSet<>();
        Vulnerability.Patch f = new Vulnerability.Patch("test_file",
                "test_date", new ArrayList<>());
        files.add(f);
        when(nc.findPatchEntry("ref")).thenReturn(Optional.of(files));

        patchFarmer.parseReferences(v, nc);
        assertTrue(v.getPatches().contains(f));
    }
}

